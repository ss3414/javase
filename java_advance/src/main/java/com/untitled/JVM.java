package com.untitled;

import org.junit.jupiter.api.Test;

public class JVM {

    /*
     * Java内存区域
     * 线程共享：堆/方法区（包括常量池）
     * 线程私有：程序计数器/Java虚拟机栈/本地方法栈
     * 直接内存
     *
     * 堆：存放对象实例，垃圾收集器主要管理的区域，可分为新生代/老年代/永久代
     * 方法区：存放类信息/常量/静态变量/即时编译器编译后的代码
     * （Java8后元空间取代方法区，元空间使用直接内存）
     * 运行时常量池：方法区的一部分，存放编译期生成的字面量和符号引用
     *
     * 程序计数器：当前线程所执行的字节码的行号指示器
     * （字节码解释器通过改变计数器读取指令/多线程下记录当前线程执行位置）
     * Java虚拟机栈：由栈帧组成，栈帧包含局部变量表（基本数据类型/对象引用）/操作数栈/动态链接/方法出口信息
     * 本地方法栈：与虚拟机栈类似，只不过虚拟机栈执行Java方法（字节码），本地方法栈执行Native方法
     *
     * Java内存堆栈，堆指内存共享的堆，栈指Java虚拟机栈
     * */

    /*
     * String类和常量池
     * */
    @Test
    public void test2() {
        String str1 = "123"; /* 先检查字符串常量池是否存在"123"，存在直接指向，不存在新建 */
        String str2 = "123";
        String str3 = new String("123"); /* 创建1/2个新对象，常量池没有"123"，常量池创建，堆中再创建 */
        System.out.println(str1 == str2);
        System.out.println(str1 == str3);

        /* 包装器类除Float/Double外也使用了常量池技术 */
        Integer i = 1; /* 等价于Integer.valueOf(1) */
        Integer j = 1;
        Integer k = new Integer(1);
        System.out.println(i == j);
        System.out.println(i == k);
    }

    /************************************************************分割线************************************************************/

    /*
     * JVM内存分配与回收
     * 堆结构：新生代（eden/s0（from）/s1（to））+老年代（tentired）
     * 对象会首先在eden区分配内存
     * 一次新生代GC后，如果对象还活着，则进入s1区，且对象年龄加1
     * 对象的年龄增加到阈值（默认15）后，则会晋升到老年代
     * 新生代GC后，eden区和s0区已被清空，此时交换s0/s1区
     *
     * 新生代GC/老年代GC
     * 新生代GC：Minor GC，频繁回收速度快
     * 老年代GC：Full GC，通常会伴随至少一次新生代GC，比新生代GC慢
     *
     * 大对象直接进入老年代（如字符串/数组）：避免大对象分配内存时因分配担保机制带来的复制而降低效率
     * 长期存活的对象进入老年代：从eden区进入s1区，年龄加1，每熬过一次新生代GC再加1，达到阈值（15）进入老年代
     * */

    /*
     * 判断对象是否死亡
     * 如何判断：引用计数法/可达性分析法
     * 引用计数法：Python中使用，Java不使用，无法解决对象循环引用的问题
     * 可达性分析法：通过被称为GC Roots的对象作为起点向下搜索，当一个对象到GC Roots没有任何引用链，则此对象已死亡
     *
     * 引用：强>软>弱>虚引用
     * 强引用：必不可少
     * 软引用：可有可无，内存不足时会被回收
     * 弱引用：可有可无，生命周期比软引用更短，一旦发现即回收
     * 虚引用：等同于没引用，任何时候都可能被回收，主要用于跟踪对象被GC
     *
     * 不可达对象未必会被回收
     * 判断常量是否废弃：常量池回收废弃常量
     * 判断类是否无用：方法区回收无用类
     * （类所有实例已被回收/加载该类的ClassLoader已被回收/该类的Class对象没有被引用，无法通过反射获取）
     * */

    /*
     * 垃圾回收算法
     * 标记-清除算法：首先标记出需要回收的对象，标记完后统一回收，效率问题/空间问题（回收后产生大量不连续的碎片）
     * 复制算法：将内存分为两块，使用一块空闲一块，当一块内存使用完后将存活对象复制到另一块，再将使用的那一块清理掉
     * 标记-整理算法：先标记，再将存活对象向一端移动，清理掉端边界以外的内存
     * 分代收集算法：Java GC使用的算法，新生代用复制算法，老年代用标记-清除/标记-整理算法
     * */

    /*
     * 垃圾收集器
     * Serial收集器：单线程GC，且GC时会暂停所有工作线程，新生代复制老年代标记-整理
     * ParNew收集器：Serial收集器的多线程版
     * Parallel Scavenge收集器：多线程收集器，注重吞吐量（运行用户代码时间/CPU总消耗时间）
     * Serial Old收集器：Serial收集器的老年代版本
     * Parallel Old收集器：Parallel Scavenge收集器的老年代版本
     * CMS收集器：注重获取最短回收停顿时间，并发收集器，可以与用户线程同时工作，标记-清除
     * G1收集器
     * */

    /************************************************************分割线************************************************************/

    /*
     * ①类加载过程
     * 步骤：加载/连接/初始化，连接又可细分为验证/准备/解析
     *
     * 加载
     * 将class文件加载到内存中
     * 将静态数据结构转换为方法区中运行时的数据结构
     * 在堆中生成一个代表这个类的Class对象作为入口
     *
     * 连接
     * 验证：确保加载的类符合JVM规范
     * 准备：为static变量在方法区中分配空间，设置初始值
     * 解析：将常量池内的符号引用替换为直接引用（指针/对象地址）
     *
     * 初始化：赋值
     * 卸载：GC将无用对象从内存中清除
     *
     * ②类加载器的加载顺序
     * Bootstrap ClassLoader：根类加载器，加载rt.jar（runtime运行时）
     * Extension ClassLoader：加载扩展的jar包
     * App ClassLoader：加载指定classpath下的jar包
     * Custom ClassLoader：自定义类加载器
     *
     * ③双亲委派
     * 当一个类收到加载请求后，首先委派给父类加载，父类无法完成再由子类加载
     * 加载位于rt.jar包中的类时（JDK），最终都会由Bootstrap ClassLoader加载，避免冲突
     * */

    /************************************************************分割线************************************************************/

    /*
     * JVM调优
     * -Xmx：最大堆内存
     * -Xms：最小堆内存
     * 默认空余堆内存小于40%时自动增加但不大于最大值，大于70%时自动减少但不小于最小值
     * */

}
